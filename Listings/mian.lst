C51 COMPILER V9.01   MIAN                                                                  05/30/2023 16:46:11 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MIAN
OBJECT MODULE PLACED IN .\Objects\mian.obj
COMPILER INVOKED BY: D:\LABORATORY\C51\BIN\C51.EXE mian.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\mian.lst)
                    - TABS(2) OBJECT(.\Objects\mian.obj)

line level    source

   1          #include<reg52.h>
   2          #include<intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define GPIO P1
   6          #define count 50000        //计数值，约为0.05s
   7          #define TH  (65536-count)/256  //定时器初始化设置
   8          #define TL  (65536-count)%256
   9          sbit LSA=P2^2;           //数码管位选设置
  10          sbit LSB=P2^3;
  11          sbit LSC=P2^4;
  12          sbit bee=P2^5;
  13          sbit LED=P2^0;
  14          sbit KEY1=P3^1;
  15          int key=0;             //矩阵键盘按键标志
  16          int password[4];         //输入数字数组
  17          int right[4]={6,6,6,6};    //正确密码数组
  18          int temporary[4];        //零时密码数组
  19          uchar code DSY[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};  //数码管显示数字数组
  20          
  21          
  22          void delay(int n)        //延时函数
  23          { int t;
  24   1        while(n--)
  25   1        { for(t=0;t<12;t++);
  26   2        }
  27   1      }
  28          void main()
  29          {
  30   1        int flag=1;
  31   1        int sign=0;          //重置密码位数
  32   1        int mark01=0;        //重置密码第一遍（原密码）标志
  33   1        int mark02=0;        //重置密码第二遍（原密码重复）标志
  34   1        int mark03=0;        //重置密码第三遍（新密码）标志
  35   1        int mark04=0;        //重置密码第四遍（新密码重复）标志
  36   1        int mistake=0;         //错误次数
  37   1        int temp=0;          //正确位数
  38   1        int N=0;           //输入位数
  39   1        int i=0;           //计数
  40   1        int a=0;           //计数
  41   1        bee=0;
  42   1        TMOD&=0X0F;          //定时器初始化设置
  43   1        TMOD|=0X01;
  44   1        P2=0X03;
  45   1        while(1)
  46   1        {
  47   2        while(1)           //进入循环
  48   2          {
  49   3            GPIO=0x0f;
  50   3            if(GPIO!=0x0f)       //判断按下
  51   3            {
  52   4              delay(100);
  53   4              if(GPIO!=0x0f)     //重新判断按下
  54   4              {
C51 COMPILER V9.01   MIAN                                                                  05/30/2023 16:46:11 PAGE 2   

  55   5                switch(N)      //位选   
  56   5                      {
  57   6                          case(0):
  58   6                                  LSA=1;LSB=1;LSC=1; break;
  59   6                          case(1):
  60   6                                  LSA=0;LSB=1;LSC=1; break;
  61   6                          case(2):
  62   6                                  LSA=1;LSB=0;LSC=1; break;
  63   6                          case(3):
  64   6                                  LSA=0;LSB=0;LSC=1; break;
  65   6      //                    case(4):
  66   6      //                            LSA=1;LSB=1;LSC=0; break;
  67   6      //                    case(5):
  68   6      //                            LSA=0;LSB=1;LSC=0; break;
  69   6                }
  70   5                GPIO=0X0F;            //测试列
  71   5                  switch(GPIO)
  72   5                  {
  73   6                    case(0x07):key=0;break;
  74   6                    case(0x0b):key=1;break;
  75   6                    case(0x0d):key=2;break;
  76   6                    case(0x0e):key=3;break;
  77   6                  }              //测试行
  78   5                GPIO=0XF0;
  79   5                switch(GPIO)
  80   5                  {
  81   6                    case(0x70):key=key;break;
  82   6                    case(0xb0):key=key+4;break;
  83   6                    case(0xd0):key=key+8;break;
  84   6                    case(0xe0):key=key+12;break;
  85   6                  }
  86   5                
  87   5      //          P0=DSY[key];          //矩阵键盘按键输出至数码管并显示
  88   5                password[N]=key;        //保存按键输入
  89   5                if(mark04==1)         //第四遍密码标志开启时，将第三遍输入密码与第四遍输入密码比对
  90   5                {
  91   6                  if(key==temporary[N])
  92   6                  sign++;
  93   6                }
  94   5                if(mark03==1)         //第三遍密码标志开启时，将输入新密码保存到临时密码数组中
  95   5                {
  96   6                  temporary[N]=key;
  97   6                }
  98   5                if(key==right[N])       //判断这一位密码是否正确并计数
  99   5                   temp++;
 100   5                if(key ==13){
 101   6                
 102   6                temporary[N]=key;       //将输入新密码保存到临时密码数组中
 103   6                
 104   6                
 105   6      }
 106   5              if (key == 14) 
 107   5            {
 108   6                while (1) 
 109   6                        {
 110   7                LSA = 1; LSB = 1; LSC = 1;
 111   7                P0 = 0x40; // 显示第一位
 112   7                LSA = 0; LSB = 1; LSC = 1;
 113   7                P0 = 0x40; // 显示第二位
 114   7                LSA = 1; LSB = 0; LSC = 1;
 115   7                P0 = 0x40; // 显示第三位
 116   7                LSA = 0; LSB = 0; LSC = 1;
C51 COMPILER V9.01   MIAN                                                                  05/30/2023 16:46:11 PAGE 3   

 117   7                P0 = 0x40; // 显示第四位
 118   7                        }
 119   6              }
 120   5      
 121   5                if(key==15)           //重新输入密码功能
 122   5                  {N=0;
 123   6                   if(mark01==1)        //输入正确密码后按S16，可输入第二遍密码
 124   6                   {mark02=1;         //第二遍密码标志开启
 125   7                    mark01=0;
 126   7                }
 127   6                   break;
 128   6                  }
 129   5                while((GPIO!=0xf0)&&(i<500))  //按键弹起
 130   5                { delay(100);
 131   6                  i++;
 132   6                }
 133   5                i=0; 
 134   5                while(1)            //进入显示循环
 135   5                  { while(1)
 136   6                    {
 137   7                     LSA=1;LSB=1;LSC=1;   //显示第一位
 138   7                     key=password[0];
 139   7                     P0=0x40;
 140   7                     delay(15); 
 141   7                     if(N==0)       
 142   7                     break;
 143   7                     LSA=0;LSB=1;LSC=1;   //显示第二位
 144   7                     key=password[1];
 145   7                     P0=0x40;
 146   7                     delay(15);
 147   7                     if(N==1)
 148   7                     break;
 149   7                     LSA=1;LSB=0;LSC=1;  //显示第三位
 150   7                     key=password[2];
 151   7                     P0=0x40;
 152   7                     delay(15);
 153   7                     if(N==2)
 154   7                     break;
 155   7                     LSA=0;LSB=0;LSC=1;  //显示第四位
 156   7                     key=password[3];
 157   7                     P0=0x40;
 158   7                     delay(15);
 159   7                     if(N==3)
 160   7                     break;
 161   7      //               LSA=1;LSB=1;LSC=0;  //显示第五位
 162   7      //               key=password[4];
 163   7      //               P0=DSY[key];
 164   7      //               delay(15);
 165   7      //               if(N==4)
 166   7      //                     break;
 167   7      //               LSA=0;LSB=1;LSC=0;  //显示第六位
 168   7      //               key=password[5];
 169   7      //               P0=DSY[key];
 170   7      //               delay(15);
 171   7      //               if(N==5)
 172   7      //                     break;
 173   7                    }
 174   6                    if(GPIO!=0xf0)     //按键再次按下退出循环
 175   6                    { delay(100);
 176   7                      if(GPIO!=0xf0)
 177   7                      break;
 178   7                    }
C51 COMPILER V9.01   MIAN                                                                  05/30/2023 16:46:11 PAGE 4   

 179   6                  }
 180   5                 
 181   5              N++;   
 182   5              }
 183   4                  
 184   4            }
 185   3            if(N==4)              //四位密码输入完成
 186   3            { if(mark03==1)         //第三遍密码标志开启并输入完四位新密码后，可进行第四遍密码输入
 187   4              {mark04=1;
 188   5               mark03=0;
 189   5              }
 190   4              if(temp!=4)           //输入错误，计数加一
 191   4              mistake++;
 192   4              while((GPIO!=0xf0)&&(i<500))  //按键弹起
 193   4                { 
 194   5                  delay(100);
 195   5                  i++;
 196   5                }
 197   4                i=0; 
 198   4              if(sign==4)           //第三遍密码与第四遍密码相同时，将此密码设置为新密码
 199   4              {
 200   5                delay(15);
 201   5                right[0]=temporary[0];
 202   5                right[1]=temporary[1];
 203   5                right[2]=temporary[2];
 204   5                right[3]=temporary[3];
 205   5                right[4]=temporary[4];
 206   5                right[5]=temporary[5];
 207   5                sign=0;
 208   5                mark04=0;
 209   5                mistake=0;
 210   5                for(flag=1;flag<100;flag++) //密码修改正确蜂鸣器响
 211   5                { bee=~bee;
 212   6                  delay(15);
 213   6                }
 214   5              }
 215   4              while(1)            //进入显示循环
 216   4              {
 217   5      //              LSA=1;LSB=1;LSC=1;     //第一位显示
 218   5      //              LSA=0;LSB=1;LSC=1;    //显示第二位
 219   5      //              LSA=1;LSB=0;LSC=1;   //显示第三位
 220   5      //              LSA=0;LSB=0;LSC=1;   //显示第四位
 221   5      //              P0=DSY[10];
 222   5      //              delay(200000);
 223   5                while(1)
 224   5                {
 225   6                    LSA=1;LSB=1;LSC=1;     //第一位显示
 226   6                    LSA=0;LSB=1;LSC=1;    //显示第二位
 227   6                    LSA=1;LSB=0;LSC=1;   //显示第三位
 228   6                    LSA=0;LSB=0;LSC=1;   //显示第四位
 229   6                    if(temp==4)       //密码正确显示8888
 230   6                  {
 231   7                   mistake=0;
 232   7                   P0=DSY[8];
 233   7                   mark01=1;        //密码输入正确时，第一遍密码标志开启
 234   7                   if(mark02==1)      //第二遍密码标志开启并第二遍输入密码正确时，第三遍密码标志开启
 235   7                   {mark03=1;
 236   8                    mark02=0;
 237   8                   }
 238   7                  }
 239   6                   else         //密码错误显示0
 240   6                  {
C51 COMPILER V9.01   MIAN                                                                  05/30/2023 16:46:11 PAGE 5   

 241   7                    P0=0x00;
 242   7                    LSA=1;LSB=1;LSC=1;     //第一位显示
 243   7                    LSA=0;LSB=1;LSC=1;    //显示第二位
 244   7                    LSA=1;LSB=0;LSC=1;   //显示第三位
 245   7                    LSA=0;LSB=0;LSC=1;   //显示第四位
 246   7                    P0=0x76;
 247   7                   if(mistake==3)     //错误次数为3时
 248   7                   {LED=0;
 249   8                    for(a=0;a<100;a++)
 250   8                    { 
 251   9                      TH0=TH;
 252   9                      TL0=TL;
 253   9                      TR0=1;
 254   9                      bee=~bee;             //蜂鸣器响
 255   9                      LSA=1;LSB=1;LSC=1;  //数码管循环显示
 256   9                      P0=DSY[8];
 257   9                      delay(50); 
 258   9                      LSA=0;LSB=1;LSC=1;
 259   9                      P0=DSY[8];
 260   9                      delay(50);
 261   9                      LSA=1;LSB=0;LSC=1;
 262   9                      P0=DSY[8];
 263   9                      delay(50);
 264   9                      LSA=0;LSB=0;LSC=1;
 265   9                      P0=DSY[8];
 266   9                      delay(50);
 267   9                      LSA=1;LSB=1;LSC=0;
 268   9                      P0=DSY[8];
 269   9                      delay(50);
 270   9                      LSA=0;LSB=1;LSC=0;
 271   9                      P0=DSY[8];
 272   9                      delay(50);
 273   9                      LSA=1;LSB=0;LSC=0;
 274   9                      P0=DSY[8];
 275   9                      delay(50);
 276   9                      LSA=0;LSB=0;LSC=0;
 277   9                      P0=DSY[8];
 278   9                      delay(50);
 279   9                    }
 280   8                   mistake=0;         //错误次数重置
 281   8                   LED=1;
 282   8                   }
 283   7                   
 284   7                  }
 285   6                  break;
 286   6                }
 287   5                if(GPIO!=0xf0)       //按键再次按下退出循环
 288   5                { delay(100);
 289   6                  if(GPIO!=0xf0)
 290   6                  break;
 291   6                }
 292   5              }
 293   4              N=0;             //密码位数重置
 294   4              temp=0;
 295   4            } 
 296   3          }
 297   2        
 298   2        }
 299   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.01   MIAN                                                                  05/30/2023 16:46:11 PAGE 6   

   CODE SIZE        =   1086    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
